"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamPublisher = exports.AmqpByte = void 0;
const util_1 = require("util");
const encoder_1 = require("./amqp10/encoder");
const compression_1 = require("./compression");
const frame_size_exception_1 = require("./requests/frame_size_exception");
const publish_request_1 = require("./requests/publish_request");
const sub_entry_batch_publish_request_1 = require("./requests/sub_entry_batch_publish_request");
const util_2 = require("./util");
const connection_pool_1 = require("./connection_pool");
const publish_request_v2_1 = require("./requests/publish_request_v2");
class AmqpByte {
    constructor(value) {
        if (value > 255 || value < 0) {
            throw new Error("Invalid byte, value must be between 0 and 255");
        }
        this.value = value;
    }
    get byteValue() {
        return this.value;
    }
}
exports.AmqpByte = AmqpByte;
class StreamPublisher {
    constructor(params, filter) {
        this.filter = filter;
        this.closed = false;
        this.connection = params.connection;
        this.stream = params.stream;
        this.publisherId = params.publisherId;
        this.publisherRef = params.publisherRef || "";
        this.boot = params.boot || false;
        this.publishingId = params.boot ? -1n : 0n;
        this.maxFrameSize = params.maxFrameSize || 1048576;
        this.queue = [];
        this.scheduled = null;
        this.logger = params.logger;
        this.maxChunkLength = params.maxChunkLength || 100;
        this.connection.incrRefCount();
    }
    async send(message, opts = {}) {
        if (this.boot && this.publishingId === -1n) {
            this.publishingId = await this.getLastPublishingId();
        }
        this.publishingId = this.publishingId + 1n;
        return this.basicSend(this.publishingId, message, opts);
    }
    basicSend(publishingId, content, opts = {}) {
        const msg = { publishingId: publishingId, message: { content: content, ...opts } };
        return this.enqueue(msg);
    }
    async flush() {
        await this.sendBuffer();
        return true;
    }
    async sendSubEntries(messages, compressionType = compression_1.CompressionType.None) {
        return this.connection.send(new sub_entry_batch_publish_request_1.SubEntryBatchPublishRequest({
            publisherId: this.publisherId,
            publishingId: this.publishingId,
            compression: this.connection.getCompression(compressionType),
            maxFrameSize: this.maxFrameSize,
            messages: messages,
        }));
    }
    getConnectionInfo() {
        const { host, port, id, writable, localPort } = this.connection.getConnectionInfo();
        return { host, port, id, writable, localPort };
    }
    on(event, listener) {
        switch (event) {
            case "metadata_update":
                this.connection.on("metadata_update", listener);
                break;
            case "publish_confirm":
                const cb = listener;
                this.connection.on("publish_confirm", (confirm) => cb(null, confirm.publishingIds));
                this.connection.on("publish_error", (error) => cb(error.publishingError.code, [error.publishingError.publishingId]));
                break;
            default:
                break;
        }
    }
    getLastPublishingId() {
        return this.connection.queryPublisherSequence({ stream: this.stream, publisherRef: this.publisherRef });
    }
    get ref() {
        return this.publisherRef;
    }
    async close() {
        if (!this.closed) {
            await this.flush();
            this.connection.decrRefCount();
            if (connection_pool_1.ConnectionPool.removeIfUnused(this.connection)) {
                await this.connection.close();
            }
        }
        this.closed = true;
    }
    async enqueue(publishRequestMessage) {
        if (this.filter) {
            publishRequestMessage.filterValue = this.filter(publishRequestMessage.message);
        }
        if (!this.connection.isFilteringEnabled && this.filter) {
            throw new Error(`Your rabbit server management version does not support filtering.`);
        }
        this.checkMessageSize(publishRequestMessage);
        const sendCycleNeeded = this.add(publishRequestMessage);
        let sent = false;
        if (sendCycleNeeded) {
            await this.sendBuffer();
            sent = true;
        }
        this.scheduleIfNeeded();
        return sent;
    }
    checkMessageSize(publishRequestMessage) {
        const computedSize = (0, encoder_1.messageSize)(publishRequestMessage.message);
        if (this.maxFrameSize !== util_2.DEFAULT_UNLIMITED_FRAME_MAX && computedSize > this.maxFrameSize) {
            throw new frame_size_exception_1.FrameSizeException(`Message too big to fit in one frame: ${computedSize}`);
        }
        return true;
    }
    async sendBuffer() {
        const chunk = this.popChunk();
        if (chunk.length > 0) {
            this.filter
                ? await this.connection.send(new publish_request_v2_1.PublishRequestV2({
                    publisherId: this.publisherId,
                    messages: chunk,
                }))
                : await this.connection.send(new publish_request_1.PublishRequest({
                    publisherId: this.publisherId,
                    messages: chunk,
                }));
        }
    }
    scheduleIfNeeded() {
        if (this.queue.length > 0 && this.scheduled === null) {
            this.scheduled = setImmediate(() => {
                this.scheduled = null;
                this.flush()
                    .then((_v) => _v)
                    .catch((err) => this.logger.error(`Error in send: ${(0, util_1.inspect)(err)}`))
                    .finally(() => this.scheduleIfNeeded());
            });
        }
    }
    add(message) {
        this.queue.push(message);
        return this.queue.length >= this.maxChunkLength;
    }
    popChunk() {
        return this.queue.splice(0, this.maxChunkLength);
    }
}
exports.StreamPublisher = StreamPublisher;
//# sourceMappingURL=publisher.js.map